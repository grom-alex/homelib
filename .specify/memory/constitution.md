<!--
  Sync Impact Report
  ===========================================================================
  Version change: 1.4.0 → 1.5.0
  Modified principles: N/A
  Added sections:
    - §7 Change Governance — добавлен «Стадия проекта»
  Removed sections: N/A
  Templates requiring updates:
    - CLAUDE.md — обновлён Current Status (MVP → production)
  Follow-up TODOs: none
  ===========================================================================
-->

# HomeLib Constitution

## 1. Core Architectural Principles

### I. Централизация управления на сервере

Вся бизнес-логика, координация процессов и принятие решений ДОЛЖНЫ
выполняться исключительно на сервере. Ollama-инстансы на Windows-машинах
являются пассивными исполнителями запросов и НЕ ДОЛЖНЫ содержать
кастомного кода, агентов или бизнес-логики. На Windows-машинах разрешена
установка ТОЛЬКО стандартного Ollama без модификаций.

### II. Разделение ответственности

Система состоит из четырёх изолированных компонентов:

- **API Server (Go/Gin или Echo):** HTTP-обработка, аутентификация, маршрутизация, конвертация форматов, координация поиска.
- **Worker (Go):** фоновые задачи — импорт INPX, извлечение метаданных, формирование саммари, генерация эмбеддингов, LLM-саммаризация.
- **PostgreSQL:** единственное хранилище данных и состояния.
- **Ollama Pool:** выполнение embedding и LLM-запросов.

Компоненты ДОЛЖНЫ взаимодействовать только через определённые интерфейсы:
API↔DB, Worker↔DB, Worker↔Ollama (HTTP), API↔Worker (через очереди в DB).
Прямое взаимодействие API↔Ollama допускается ТОЛЬКО для embedding
поискового запроса в реальном времени.

### III. Stateless API

API Server ДОЛЖЕН быть stateless. Аутентификация — исключительно через
JWT-токены. Состояние сессий, кеш пользовательских данных и локальные
хранилища на стороне API-сервера ЗАПРЕЩЕНЫ. Всё состояние хранится
в PostgreSQL или передаётся через токены.

### IV. Чтение из архивов без распаковки

Книги НЕ ДОЛЖНЫ извлекаться из ZIP-архивов на файловую систему. Чтение
файлов ДОЛЖНО выполняться на лету через Go `archive/zip` с использованием
random access по offset. Допускается кеширование результатов конвертации
(FB2→HTML) на диск.

### V. Семантический поиск только по summary embeddings

Векторный поиск ДОЛЖЕН выполняться исключительно по эмбеддингам саммари
книг (summary embedding). Chunking полного текста книг ЗАПРЕЩЁН.
Это обеспечивает масштаб ~500K векторов вместо ~75M, сокращая объём
хранения в ~80 раз.

### VI. Идемпотентный импорт INPX

Импорт INPX-файлов ДОЛЖЕН быть идемпотентным. Повторный импорт того же
файла НЕ ДОЛЖЕН создавать дубликатов. Уникальность записей обеспечивается
ключом `(collection_id, lib_id)`. Поддерживается инкрементальный импорт
при обновлении версии коллекции.

### VII. Отсутствие внешних SaaS-зависимостей

Система ДОЛЖНА быть полностью self-hosted. Зависимости от внешних
облачных сервисов, SaaS API, внешних LLM-провайдеров (OpenAI, Anthropic
и др.) ЗАПРЕЩЕНЫ. Все вычисления выполняются локально: на сервере
или на машинах Ollama Pool в локальной сети.

## 2. Data & Storage Principles

### I. Единая PostgreSQL как источник истины

PostgreSQL — ЕДИНСТВЕННАЯ база данных системы. Использование дополнительных
СУБД (Redis, MongoDB, Elasticsearch и др.) ЗАПРЕЩЕНО. Все типы поиска
реализуются расширениями PostgreSQL:

- Полнотекстовый поиск: `tsvector` + `GIN`-индекс
- Нечёткий поиск: `pg_trgm` + `GIN`-индекс
- Семантический поиск: `pgvector` + `HNSW`-индекс

### II. Явные M:N связи

Связи «многие ко многим» ДОЛЖНЫ реализовываться через явные
связующие таблицы (`book_authors`, `book_genres`, `shelf_books`).
Хранение массивов ID или JSON-массивов для M:N связей ЗАПРЕЩЕНО.

### III. Автоматическое обновление поисковых индексов

Обновление `tsvector` для полнотекстового поиска ДОЛЖНО выполняться
автоматически через триггеры на уровне БД (`BEFORE INSERT OR UPDATE`).
Обновление `tsvector` на уровне приложения ЗАПРЕЩЕНО — это
гарантирует целостность индекса независимо от источника изменений.

### IV. HNSW для векторного поиска

Индекс эмбеддингов ДОЛЖЕН использовать алгоритм HNSW
(`vector_cosine_ops`). Индекс создаётся ТОЛЬКО по записям с
ненулевым вектором (`WHERE embedding IS NOT NULL`).

### V. Запрет дублирования бизнес-данных вне БД

Бизнес-данные (каталог, пользователи, прогресс чтения, рейтинги)
ДОЛЖНЫ храниться ТОЛЬКО в PostgreSQL. Дублирование этих данных
в файлах, кешах или иных хранилищах для бизнес-логики ЗАПРЕЩЕНО.
Допускается кеширование ТОЛЬКО для производительности чтения
(обложки, сконвертированные файлы) с возможностью полной
регенерации из БД и архивов.

### VI. Инкрементальный импорт коллекций

Импорт ДОЛЖЕН поддерживать инкрементальное обновление:
сравнение версий через `version.info`, upsert записей по
`ON CONFLICT (collection_id, lib_id)`, пакетная обработка.
Полное пересоздание данных при повторном импорте ЗАПРЕЩЕНО.

## 3. AI & Embedding Principles

### I. Embedding через summary, не через полный текст

Для семантического поиска используются ТОЛЬКО эмбеддинги саммари
(~500–2000 символов на книгу). Составное саммари формируется из:
аннотации, метаданных (автор, жанр, серия), оглавления,
первых параграфов, ключевых слов. Индексация полного текста
книг для семантического поиска ЗАПРЕЩЕНА.

### II. LLM только для улучшения описаний

LLM (llama3, mistral и др.) используется ИСКЛЮЧИТЕЛЬНО для
генерации текстовых описаний книг, у которых отсутствует
или недостаточна аннотация. Использование LLM для других целей
(генерация кода, чат с пользователем, классификация) НЕ ВХОДИТ
в scope проекта без изменения конституции.

### III. Асинхронная обработка LLM-запросов

Все запросы к LLM ДОЛЖНЫ обрабатываться асинхронно через очередь
задач в БД (`llm_summary_tasks`). Синхронные запросы к LLM
из API-хэндлеров ЗАПРЕЩЕНЫ. Результат доставляется при следующем
обращении к данным книги.

### IV. Приоритетная очередь

Очередь LLM-задач ДОЛЖНА поддерживать приоритеты. Ручные запросы
пользователей ДОЛЖНЫ иметь более высокий приоритет, чем
автоматические (отсутствие аннотации, пакетная обработка).

### V. Least-connections балансировка

Распределение запросов по Ollama-инстансам ДОЛЖНО выполняться
по алгоритму least-connections: запрос направляется на инстанс
с минимальным числом активных соединений. Балансировка ДОЛЖНА
быть раздельной для embedding и LLM запросов.

### VI. Автоматический fallback на CPU

При недоступности всех GPU-инстансов система ДОЛЖНА автоматически
переключаться на CPU-инстанс Ollama (при его наличии в конфигурации).
Отсутствие GPU-инстансов НЕ ДОЛЖНО приводить к полной остановке
embedding-пайплайна.

### VII. Контроль лимитов генерации

Система ДОЛЖНА поддерживать настраиваемые дневные лимиты
LLM-генерации для предотвращения чрезмерной нагрузки на GPU-машины.
Превышение лимита ДОЛЖНО приостанавливать автоматическую генерацию,
но НЕ ДОЛЖНО блокировать ручные запросы администратора.

## 4. Security Model

### I. JWT-аутентификация

Аутентификация — ИСКЛЮЧИТЕЛЬНО через JWT:

- **Access token:** время жизни 15 минут, хранение ТОЛЬКО в памяти
  (Pinia store). Хранение в `localStorage` или `sessionStorage` ЗАПРЕЩЕНО.
- **Refresh token:** время жизни 30 дней, хранение ТОЛЬКО в `httpOnly`
  cookie. Передача refresh-токена в теле запроса или JavaScript ЗАПРЕЩЕНА.

### II. Изоляция административных эндпоинтов

Все эндпоинты `/api/admin/*` ДОЛЖНЫ быть защищены отдельным middleware,
проверяющим роль `admin` из JWT claims. Административная функциональность
НЕ ДОЛЖНА быть доступна через общие эндпоинты.

### III. Изоляция пользовательских данных

Все операции с пользовательскими данными (полки, прогресс чтения,
рейтинги, заметки) ДОЛЖНЫ фильтроваться по `user_id` из JWT-токена.
Передача `user_id` как параметра запроса для пользовательских
эндпоинтов ЗАПРЕЩЕНА.

### IV. Управление регистрацией

Система ДОЛЖНА поддерживать отключение публичной регистрации
через конфигурацию (`auth.registration_enabled`). При первом запуске
с пустой БД первый зарегистрированный пользователь автоматически
получает роль `admin`.

### V. Хеширование паролей и токенов

Пароли ДОЛЖНЫ храниться ТОЛЬКО в виде bcrypt-хешей. Refresh-токены
ДОЛЖНЫ храниться в БД ТОЛЬКО в виде SHA-256 хешей. Хранение
паролей или токенов в открытом виде ЗАПРЕЩЕНО.

## 5. Performance Model

### I. Batch-операции при импорте

Импорт INPX ДОЛЖЕН выполняться пакетами по 1000–5000 записей
за транзакцию. Вставка записей по одной ЗАПРЕЩЕНА. Целевая
производительность: 600K+ книг за 1–3 минуты.

### II. Параллельные воркеры

Worker ДОЛЖЕН поддерживать параллельное выполнение задач:
несколько горутин для embedding, несколько для LLM-саммаризации.
Количество параллельных воркеров ДОЛЖНО быть настраиваемым
через конфигурацию.

### III. Ограничение конкурентности

Количество одновременных запросов к Ollama Pool ДОЛЖНО быть
ограничено (настраиваемый параметр `concurrency`). Неконтролируемый
рост числа параллельных запросов к GPU-инстансам ЗАПРЕЩЁН.

### IV. Комбинированная индексация

Для обеспечения производительности поиска ДОЛЖНЫ использоваться
три типа индексов одновременно:

- `GIN (gin_trgm_ops)` — для нечёткого поиска по названиям и авторам
- `GIN (tsvector)` — для полнотекстового поиска
- `HNSW (vector_cosine_ops)` — для семантического поиска

### V. Кеширование на уровне Nginx

Nginx ДОЛЖЕН обеспечивать кеширование статики, обложек книг
и сконвертированных файлов. Gzip/Brotli сжатие ДОЛЖНО быть
включено для текстовых ресурсов.

## 6. Operational Model

### I. Docker Compose как единственный оркестратор

Развёртывание серверной части ДОЛЖНО выполняться через Docker Compose.
Kubernetes, Docker Swarm и другие оркестраторы НЕ ВХОДЯТ в scope
проекта. Инфраструктура ДОЛЖНА быть достаточно простой для
обслуживания одним человеком.

### II. Масштаб: домашняя библиотека

Проект проектируется под масштаб ~600–700K книг и единицы
одновременных пользователей. Оптимизация под многомиллионную
нагрузку или тысячи пользователей НЕ ТРЕБУЕТСЯ и НЕ ДОЛЖНА
усложнять архитектуру.

### III. Библиотека монтируется read-only

Директория с ZIP-архивами книг и INPX-файлами ДОЛЖНА монтироваться
в контейнер как read-only volume. Запись в библиотечную директорию
ЗАПРЕЩЕНА.

### IV. Health monitoring Ollama Pool

Worker ДОЛЖЕН выполнять периодическую проверку доступности
Ollama-инстансов (healthcheck каждые 30 секунд через `/api/tags`).
Недоступные инстансы ДОЛЖНЫ автоматически исключаться из пула
и возвращаться при восстановлении.

### V. Конфигурация через YAML

Конфигурация системы (Ollama pool, лимиты, параметры embedding
и LLM) ДОЛЖНА задаваться через YAML-файл. Hardcode параметров,
влияющих на работу пула или лимиты генерации, ЗАПРЕЩЁН.

### VI. GitHub Flow как модель разработки

Разработка ДОЛЖНА вестись по модели GitHub Flow:

- Ветка `master` — основная, ВСЕГДА в deployable состоянии.
  Прямые коммиты в `master` ЗАПРЕЩЕНЫ.
- Каждая фича или исправление разрабатывается в отдельной ветке
  от `master` с именованием `NNN-short-name`.
- Вливание изменений в `master` — ТОЛЬКО через Pull Request.
- PR ДОЛЖЕН пройти CI-проверки (сборка, тесты, линтеры) перед мержем.
- GitHub Actions используется как CI/CD платформа.

### VII. Архитектурная документация как строгая спецификация

Актуальный документ архитектуры (`docs/homelib-architecture-v8.md`)
является СТРОГОЙ спецификацией структуры проекта. Структура файлов
и директорий ДОЛЖНА соответствовать описанному в разделе 7 документа
архитектуры. Отклонения от структуры ЗАПРЕЩЕНЫ без предварительного
обновления документа архитектуры. При создании новых файлов или
директорий НЕОБХОДИМО убедиться, что они соответствуют описанной
структуре или обновить документ архитектуры до внесения изменений.

## 7. Change Governance

### Статус конституции

Конституция является верховным документом проекта. Все архитектурные
решения, спецификации, планы и задачи ДОЛЖНЫ соответствовать
принципам конституции. При обнаружении противоречия между
конституцией и любым другим документом — конституция имеет приоритет.

### Процедура внесения изменений

Изменение конституции требует:

1. Создание Architecture Decision Record (ADR) с обоснованием
   изменения, анализом альтернатив и оценкой влияния.
2. Обновление конституции с инкрементом версии.
3. Проверка и обновление всех зависимых артефактов
   (спецификации, планы, задачи).

### Версионирование

Версия конституции следует семантическому версионированию:

- **MAJOR:** удаление или несовместимое переопределение принципа
- **MINOR:** добавление нового принципа или существенное расширение
- **PATCH:** уточнение формулировок без изменения смысла

### Стандарты для новых модулей

Любой новый модуль или компонент системы ДОЛЖЕН:

- Соответствовать принципу разделения ответственности (§1.II)
- Хранить данные ТОЛЬКО в PostgreSQL (§2.I)
- Не вводить внешних SaaS-зависимостей (§1.VII)
- Быть развёртываемым через Docker Compose (§6.I)
- Иметь настраиваемую конфигурацию через YAML (§6.V)
- Иметь покрытие unit-тестами не менее 80%

### Требования к тестированию

Покрытие кода unit-тестами ДОЛЖНО составлять не менее 80% для каждого
пакета/модуля — как для бэкенда (Go packages), так и для фронтенда
(Vue 3 components/composables/stores). CI-пайплайн ДОЛЖЕН проверять
уровень покрытия и блокировать мерж при несоответствии порогу.
Исключения допускаются ТОЛЬКО для сгенерированного кода, миграций БД,
конфигурационных файлов и чисто декларативных шаблонов (HTML/CSS).

### Test-Driven Development (TDD)

При разработке нового функционала РЕКОМЕНДУЕТСЯ использовать подход
Test-Driven Development: сначала написать тесты, убедиться что они
падают (red), затем реализовать код до прохождения тестов (green).
Это обеспечивает полное покрытие нового кода тестами и помогает
проектировать чистые интерфейсы. TDD ОБЯЗАТЕЛЕН для исправления
багов — перед фиксом ДОЛЖЕН быть написан тест, воспроизводящий
ошибку.

### Стадия проекта

MVP завершён (каталог, импорт INPX, аутентификация, базовый UI).
Проект находится в стадии **production-разработки**: реализуются
полноценные функциональные модули (читалка, поиск, AI-фичи).
Все новые фичи ДОЛЖНЫ реализовываться в production-качестве:
полная обработка edge cases, корректная работа на мобильных
устройствах, сохранение пользовательских данных между сессиями.
Упрощения уровня «MVP/прототип» (заглушки, хардкод, пропуск
edge cases) ЗАПРЕЩЕНЫ без явного обоснования в плане реализации.

### Compliance review

При создании спецификации или плана реализации новой фичи ДОЛЖНА
выполняться проверка соответствия конституции (Constitution Check).
Нарушения принципов ДОЛЖНЫ быть явно задокументированы и обоснованы
в секции «Complexity Tracking» плана реализации.

**Version**: 1.5.0 | **Ratified**: 2026-02-15 | **Last Amended**: 2026-02-18
